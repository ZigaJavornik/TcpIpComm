<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_LaudaPro_P20" Id="{cbfeb6cd-1449-4be7-bbd0-eed5b27b74dd}" SpecialFunc="None">
    <Declaration><![CDATA[// LaudaPro P20 control
FUNCTION_BLOCK FB_LaudaPro_P20

VAR_INPUT
	fTemperatureSet	: REAL;	// Temperature setpoint
	bSafetyOk		: BOOL;	// Safety mode actiation when FALSE
	bEnable			: BOOL;	// Enable temperature setting
	nPumpStage		: UINT := 2;	// Set pump stage 1-6
	bConnect		: BOOL;
	bKeyboardUnlock	: BOOL;
	bResendValues	: BOOL;
END_VAR


VAR

	
	fbTcpIpControl		: FB_TcpIpCommControl;
	stCommParameters	: ST_LaudaCommParameters;	
	TonReadCycleTimer	: Tc2_Standard.TON;
	
	fPrevTemperatureSet	: REAL;
	bPrevSafetyOk		: BOOL;
	bPrevEnable			: BOOL;
	nPrevPumpStage		: UINT;
	bPrevKeyboardUnlock	: BOOL;
	RtrigResendValues	: Tc2_Standard.R_TRIG;
	
	
	sResponse			: Tc2_System.T_MaxString;
	TonReconnectTimer	: Tc2_Standard.TON;
	bFirstExecution		: BOOL := TRUE;
	arrCommandBuffer	: ARRAY[0..100] OF Tc2_System.T_MaxString;
	arrResponseBuffer	: ARRAY [0..1] OF ARRAY[0..100] OF Tc2_System.T_MaxString;
	
	eSendCommandState	: (READY, SEND, VALIDATE_RESPONSE);
	eReadParametersStep	: E_LaudaParameterReadState;
	sReadResponseString	: Tc2_System.T_MaxString;
	
	_actualValues				: ST_LaudaActualValuesCollection;
	_error						: BOOL;	// Error flag
	_tcpIpConnectionEstablished	: BOOL;	// Connection indicator
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[_error := FALSE;

TonReconnectTimer(IN := NOT TonReconnectTimer.Q, pt := stCommParameters.ReconnectPeriod);
RtrigResendValues(CLK := bResendValues);

// Set reconnect period
fbTcpIpControl.ReconnectPeriod := stCommParameters.ReconnectPeriod;
fbTcpIpControl();

IF bConnect THEN
	// Connect/disconnect/error
	IF fbTcpIpControl.Error AND NOT TonReconnectTimer.Q THEN
		fbTcpIpControl.Disconnect();
	ELSIF fbTcpIpControl.IsConnected = FALSE THEN
		fbTcpIpControl.Connect(Ipv4Address := stCommParameters.Ipv4Address, Port := stCommParameters.Port);
	END_IF
ELSE
	fbTcpIpControl.Disconnect();
END_IF


// Enqueue commands

// Temperature setpoint
IF fPrevTemperatureSet <> fTemperatureSet OR bFirstExecution OR RtrigResendValues.Q THEN
	EnqueueCommand(Command :=
		LaudaHelper.GenerateComand().SetTemperature(fTemperature := fTemperatureSet));
END_IF

// Enable/Disable
IF bPrevEnable <> bEnable OR bFirstExecution OR RtrigResendValues.Q THEN
	IF bEnable THEN
		EnqueueCommand(Command := LaudaHelper.AddSuffix(LaudaHelper.Commands.Write.Status.Start));
	ELSE
		EnqueueCommand(Command := LaudaHelper.AddSuffix(LaudaHelper.Commands.Write.Status.Stop));	
	END_IF	
END_IF

// Safety
IF bPrevSafetyOk <> bSafetyOk OR bFirstExecution OR RtrigResendValues.Q THEN
	IF bSafetyOk THEN
		EnqueueCommand(LaudaHelper.GenerateComand().SafetyDeactivate());
	ELSE
		EnqueueCommand(LaudaHelper.GenerateComand().SafetyActivate());
	END_IF
END_IF

// Pump stage
IF nPrevPumpStage <> nPumpStage OR bFirstExecution OR RtrigResendValues.Q THEN
	EnqueueCommand(LaudaHelper.GenerateComand().SetPumpStage(nStage := nPumpStage));
END_IF

IF bPrevKeyboardUnlock <> bKeyboardUnlock OR bFirstExecution OR RtrigResendValues.Q THEN
	IF bKeyboardUnlock THEN
		EnqueueCommand(Command := LaudaHelper.GenerateComand().KeyboardMaserUnlock());
		EnqueueCommand(Command := LaudaHelper.GenerateComand().KeyboardRemoteUnitUnlock());
	ELSE
			EnqueueCommand(Command := LaudaHelper.GenerateComand().KeyboardMaserLock());
		EnqueueCommand(Command := LaudaHelper.GenerateComand().KeyboardRemoteUnitLock());
	END_IF
END_IF

CASE eSendCommandState OF
	READY:
		IF arrCommandBuffer[0] <> '' AND eReadParametersStep = E_LaudaParameterReadState.READY THEN
			eSendCommandState := SEND;
		END_IF
	
	SEND:
		IF NOT fbTcpIpControl.Error AND_THEN fbTcpIpControl.SendAscii(sCommand := arrCommandBuffer[0], refResponse := sResponse) THEN
			eSendCommandState := VALIDATE_RESPONSE;
		END_IF
	
	VALIDATE_RESPONSE:
		_error := LaudaHelper.ValidateSendCommandResponse(sResponse := sResponse);
		AddToResponseBuffer();
		DequeueCommand();
		eSendCommandState := READY;
END_CASE

fPrevTemperatureSet := fTemperatureSet;
bPrevEnable := bEnable;
bPrevSafetyOk := bSafetyOk;
nPrevPumpStage := nPumpStage;
bPrevKeyboardUnlock := bKeyboardUnlock;

// Cyclic reading of values
TonReadCycleTimer(
	IN := NOT TonReadCycleTimer.Q AND (eSendCommandState = READY), 
	PT := stCommParameters.ReadCycle);

CASE eReadParametersStep OF
	E_LaudaParameterReadState.READY:
		IF eSendCommandState = READY AND TonReadCycleTimer.Q THEN
			eReadParametersStep := E_LaudaParameterReadState.BAH_OUTFLOW_TEMP;
		END_IF
		
	E_LaudaParameterReadState.BAH_OUTFLOW_TEMP:
		IF NOT fbTcpIpControl.Error AND fbTcpIpControl.SendAscii(
			sCommand := LaudaHelper.AddSuffix(LaudaHelper.Commands.Read.Temperature.BathTemperatureOutflow_01C), 
			refResponse := sReadResponseString) 
		THEN
			_error := _error OR NOT LaudaHelper.ValidateReadCommandResponse(sResponse := sReadResponseString);
			IF NOT _error THEN
				_actualValues.BathTemperature := STRING_TO_REAL(LaudaHelper.RemoveSuffix(sReadResponseString));
			END_IF
			eReadParametersStep := E_LaudaParameterReadState.ACTUAL_TEMPERATURE_SETPOINT;
		END_IF
		
	E_LaudaParameterReadState.ACTUAL_TEMPERATURE_SETPOINT:
		IF NOT fbTcpIpControl.Error AND fbTcpIpControl.SendAscii(
				sCommand := LaudaHelper.AddSuffix(LaudaHelper.Commands.Read.Temperature.TemperatureSetpoint), 
				refResponse := sReadResponseString) 
		THEN
			_error := _error OR NOT LaudaHelper.ValidateReadCommandResponse(sResponse := sReadResponseString);
			IF NOT _error THEN
				_actualValues.TemperatureSetpoint := STRING_TO_REAL(LaudaHelper.RemoveSuffix(sReadResponseString));
			END_IF
			eReadParametersStep := E_LaudaParameterReadState.PUMP_STAGE;
		END_IF
		
	E_LaudaParameterReadState.PUMP_STAGE:
		IF NOT fbTcpIpControl.Error AND fbTcpIpControl.SendAscii(sCommand :=
				LaudaHelper.AddSuffix(LaudaHelper.Commands.Read.Pump.PowerStage),
				refResponse := sReadResponseString)
		THEN
			_error := _error OR NOT LaudaHelper.ValidateReadCommandResponse(sResponse := sReadResponseString);
			IF NOT _error THEN
				_actualValues.PumpStage := STRING_TO_UINT(Tc2_Standard.LEFT(STR := LaudaHelper.RemoveSuffix(sReadResponseString), SIZE := 1));
			END_IF
			eReadParametersStep := E_LaudaParameterReadState.READ_ENABLE_STATE;
		END_IF
	
	E_LaudaParameterReadState.READ_ENABLE_STATE:
		IF NOT fbTcpIpControl.Error AND fbTcpIpControl.SendAscii(sCommand :=
				LaudaHelper.AddSuffix(LaudaHelper.Commands.Read.Status.StandBy),
				refResponse := sReadResponseString)
		THEN
			_error := _error OR NOT LaudaHelper.ValidateReadCommandResponse(sResponse := sReadResponseString);
			_actualValues.StandBy := STRING_TO_BOOL(LaudaHelper.RemoveSuffix(sReadResponseString));
			eReadParametersStep := E_LaudaParameterReadState.OIL_LEVEL;
		END_IF
	
	E_LaudaParameterReadState.OIL_LEVEL:
		IF NOT fbTcpIpControl.Error AND fbTcpIpControl.SendAscii(sCommand :=
				LaudaHelper.AddSuffix(LaudaHelper.Commands.Read.FillLevel.BathLevel),
				refResponse := sReadResponseString)
		THEN
			_error := _error OR NOT LaudaHelper.ValidateReadCommandResponse(sResponse := sReadResponseString);
			_actualValues.LiquidLevel := STRING_TO_UINT(LaudaHelper.RemoveSuffix(sReadResponseString));
			eReadParametersStep := E_LaudaParameterReadState.DONE;
		END_IF	
		
	E_LaudaParameterReadState.DONE:
		eReadParametersStep := E_LaudaParameterReadState.READY;
END_CASE

_tcpIpConnectionEstablished := fbTcpIpControl.IsConnected;
bFirstExecution := FALSE;]]></ST>
    </Implementation>
    <Property Name="ActualValues" Id="{2fc7ee59-ff61-0267-361b-16cfacf7afaa}">
      <Declaration><![CDATA[// Collection of actual values reported back from Lauda device
PROPERTY PUBLIC ActualValues : REFERENCE TO ST_LaudaActualValuesCollection]]></Declaration>
      <Get Name="Get" Id="{9d3efff5-79c4-0896-3afb-bc625ce727dc}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ActualValues ref= _actualValues;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="AddToResponseBuffer" Id="{b4d690a4-525c-02fa-083c-4fcc2dcdd193}">
      <Declaration><![CDATA[METHOD PRIVATE AddToResponseBuffer
VAR_INPUT
END_VAR
VAR
	i	: int;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := 0 TO 99 BY 1 DO
	arrResponseBuffer[0][i] := arrResponseBuffer[0][i + 1];
	arrResponseBuffer[1][i] := arrResponseBuffer[0][i + 1];
END_FOR

arrResponseBuffer[0][0] := arrCommandBuffer[0];
arrResponseBuffer[1][0] := sResponse;]]></ST>
      </Implementation>
    </Method>
    <Property Name="CommParameters" Id="{c3e16bc9-a4cc-4b05-9799-55162badeedb}">
      <Declaration><![CDATA[// Gets or sets various communication specific parameters
PROPERTY CommParameters : REFERENCE TO ST_LaudaCommParameters]]></Declaration>
      <Get Name="Get" Id="{e16a1ca0-88cb-4ece-9171-ac45dcaf3038}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[CommParameters ref= stCommParameters;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{ee23e012-70a8-42d5-9bb8-c2a8b6c56b05}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[stCommParameters := CommParameters;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="DequeueCommand" Id="{d5fe71ec-6967-4740-bee3-d47dd9f230a9}">
      <Declaration><![CDATA[METHOD PRIVATE DequeueCommand
VAR_INPUT
END_VAR

VAR
	i	: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := 0 TO 99 BY 1 DO
	arrCommandBuffer[i] := arrCommandBuffer[i+1];
	IF i = 99 THEN
		arrCommandBuffer[100] := '';
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="EnqueueCommand" Id="{f7fdbf6b-2e52-42d8-8058-3875706d9c35}">
      <Declaration><![CDATA[METHOD PRIVATE EnqueueCommand
VAR_INPUT
	Command	: Tc2_System.T_MaxString;
END_VAR

VAR
	i	: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := 0 TO 100 BY 1 DO
	// If finding an empty command in queue or a new value, enter it here
	IF arrCommandBuffer[i] = '' THEN
		arrCommandBuffer[i] := Command;
		EXIT;
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Property Name="Error" Id="{fe1e87a3-6b72-0768-1222-c4b05c02bc55}">
      <Declaration><![CDATA[// Error flag
PROPERTY Error : BOOL]]></Declaration>
      <Get Name="Get" Id="{c9343a5f-c39b-04e7-32d6-a63f9488acc5}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Error := _error;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="TcpIpConnectionEstablished" Id="{de27873f-00ac-0c35-2145-4bf047c24c94}">
      <Declaration><![CDATA[// TcpIp connection status, TRUE if connected
PROPERTY PUBLIC TcpIpConnectionEstablished : BOOL]]></Declaration>
      <Get Name="Get" Id="{da818e56-6531-009c-1526-758d14f639e2}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[TcpIpConnectionEstablished := _tcpIpConnectionEstablished;]]></ST>
        </Implementation>
      </Get>
    </Property>
  </POU>
</TcPlcObject>