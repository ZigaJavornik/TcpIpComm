<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_TcpIpCommControl" Id="{fd79d544-45d1-463d-8e94-298cab5b93fb}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_TcpIpCommControl

VAR
	_socketCloseAll	: Tc2_TcpIp.FB_SocketCloseAll;
	_socketReceive	: Tc2_TcpIp.FB_SocketReceive;
	_socketSend		: Tc2_TcpIp.FB_SocketSend;
	_error			: BOOL;
	_isConnected	: BOOL;
	_clientServerControl	: Tc2_TcpIp.FB_ClientServerConnection;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[_clientServerControl( nMode := Tc2_TcpIp.CONNECT_MODE_ENABLEDBG);
_socketCloseAll(bExecute := FALSE, sSrvNetId := '');]]></ST>
    </Implementation>
    <Method Name="Connect" Id="{e1b034f2-070e-4d08-81cf-cdc063f262be}">
      <Declaration><![CDATA[METHOD Connect : BOOL
VAR_INPUT
	Ipv4Address	: Tc2_System.T_IPv4Addr;
	Port		: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.IsConnected = FALSE THEN
	_clientServerControl.bEnable := TRUE;
	_clientServerControl.sRemoteHost := Ipv4Address;
	_clientServerControl.nRemotePort := Port;
	_clientServerControl.sSrvNetID := '';
ELSE
	Connect := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Disconnect" Id="{d19beda7-1d0e-4fc3-a093-6322a6422700}">
      <Declaration><![CDATA[METHOD Disconnect : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[_clientServerControl.bEnable := FALSE;
IF _clientServerControl.hSocket.handle <> 0 THEN
	_socketCloseAll(bExecute := FALSE, sSrvNetId := '');
	_socketCloseAll(bExecute := TRUE, sSrvNetId := '');
END_IF
Disconnect := NOT THIS^.IsConnected;


]]></ST>
      </Implementation>
    </Method>
    <Property Name="Error" Id="{60d8bc34-46e0-454f-8a36-60e55751a023}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'variable'}
PROPERTY Error : BOOL]]></Declaration>
      <Get Name="Get" Id="{532dae0a-8ce1-4636-9534-c59315d8a95b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Error := _clientServerControl.bError OR (_clientServerControl.eState = Tc2_TcpIp.E_SocketConnectionState.eSOCKET_SUSPENDED and not _clientServerControl.bBusy);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsConnected" Id="{62428a97-7ac1-4a7f-b09f-13dad2b343d4}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'variable'}
PROPERTY PUBLIC IsConnected : BOOL]]></Declaration>
      <Get Name="Get" Id="{eb13dccb-aa08-41f0-8bbc-7f030a9f8461}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsConnected := _clientServerControl.eState = Tc2_TcpIp.E_SocketConnectionState.eSOCKET_CONNECTED;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Read" Id="{3cf339fe-d3bf-0523-1dff-a9d13aa44b43}">
      <Declaration><![CDATA[METHOD PUBLIC Read : BOOL
VAR_INPUT
	refResponse	: REFERENCE TO Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[_socketReceive(
	bExecute := NOT _socketReceive.bBusy,
	hSocket := _clientServerControl.hSocket,
	cbLen := SIZEOF(refResponse),
	sSrvNetId := '',
	pDest := ADR(refResponse));
	
Read := NOT _socketReceive.bBusy;]]></ST>
      </Implementation>
    </Method>
    <Property Name="ReconnectPeriod" Id="{aad75e38-b8e4-4d9a-9646-b55bad013266}">
      <Declaration><![CDATA[(* Gets or sets the reconnect period. 
The value should not be set too low, since timeout periods of > 30 s may occur in the event of a network interruption. 
If the value is too low, command execution would be interrupted prematurely, and ADS error code 1861 (timeout elapsed) 
would be returned instead of the Winsocket error WSAETIMEDOUT.*)
PROPERTY PUBLIC ReconnectPeriod : TIME]]></Declaration>
      <Get Name="Get" Id="{bbe352d2-810d-4338-953d-1a213042f053}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ReconnectPeriod := _clientServerControl.tReconnect;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{5692ca9f-3fd5-4406-95fe-a74a18518302}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF ReconnectPeriod > T#30S THEN
	_clientServerControl.tReconnect := ReconnectPeriod;
END_IF
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="SendAscii" Id="{ce4f5b3c-a3f8-4f3f-9b3a-39768c4c33f7}">
      <Declaration><![CDATA[// Sends ASCII data via TCP/IP and returns TRUE when done. Response can be found in the refResponse.
METHOD SendAscii : BOOL
VAR_INPUT
	sCommand						: Tc2_System.T_MaxString;	// Command to be send
	refResponse						: REFERENCE TO Tc2_System.T_MaxString;	// Response variable - data is written to this variable
END_VAR

VAR_INST
	state				: E_SocketSendState;
	arrSendDataBytes	: ARRAY[0..255] OF BYTE;
	nSendDataCount		: UDINT;
	response	: Tc2_System.T_MaxString;
	TonDelay	: TON := (PT := T#200MS);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE state OF
	E_SocketSendState.READY:
		_socketReceive(bExecute := FALSE);
		IF sCommand <> '' THEN
			// Clear array for new data
			Tc2_System.MEMSET(
				destAddr := ADR(arrSendDataBytes),
				n := SIZEOF(arrSendDataBytes),
				fillByte := 0);
				
			// Prepare data
			Tc2_System.MEMCPY(
				destAddr := ADR(arrSendDataBytes),
				n := SIZEOF(sCommand),
				srcAddr := ADR(sCommand));

			response := '';
			// Get the data count, no empty bytes
			nSendDataCount := 0;
			FOR nSendDataCount := 0 TO SIZEOF(arrSendDataBytes) BY 1 DO
				IF arrSendDataBytes[nSendDataCount] = 0 THEN
					EXIT;
				END_IF
			END_FOR

			// Send data
			_socketSend(
				bExecute := TRUE,
				cbLen := nSendDataCount,
				pSrc := ADR(arrSendDataBytes),
				hSocket := _clientServerControl.hSocket);
				
			state := E_SocketSendState.SENDING;
		END_IF
	
	E_SocketSendState.SENDING:
		_socketSend(bExecute := FALSE);
		IF _socketSend.bError THEN 
			state := E_SocketSendState.ERROR;
		ELSIF _socketSend.bBusy = FALSE THEN
			TonDelay(IN := TRUE);
			IF TonDelay.Q THEN
				TonDelay(IN := FALSE);
				state := E_SocketSendState.AWAIT_RESPONSE;
				_socketReceive(bExecute := FALSE);
				_socketReceive(
					bExecute := TRUE,
					hSocket := _clientServerControl.hSocket,
					cbLen := SIZEOF(response),
					pDest := ADR(response),
					tTimeout := T#5S);
			END_IF
		END_IF
		
	E_SocketSendState.AWAIT_RESPONSE:
		_socketReceive(bExecute := FALSE);
		IF _socketReceive.bError THEN
			state := E_SocketSendState.ERROR;
		ELSIF _socketReceive.bBusy = FALSE THEN
			state := E_SocketSendState.READY;
			refResponse := response;
			SendAscii := TRUE;
		END_IF
	
	E_SocketSendState.ERROR:
		THIS^.Disconnect();
		state := E_SocketSendState.READY;
END_CASE]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>