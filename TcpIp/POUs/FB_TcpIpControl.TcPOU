<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_TcpIpControl" Id="{fd79d544-45d1-463d-8e94-298cab5b93fb}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_TcpIpControl

VAR
	_socketCloseAll	: Tc2_TcpIp.FB_SocketCloseAll;
	_socketReceive	: Tc2_TcpIp.FB_SocketReceive;
	_socketSend		: Tc2_TcpIp.FB_SocketSend;
	_error			: BOOL;
	_isConnected	: BOOL;
	_clientServerControl	: Tc2_TcpIp.FB_ClientServerConnection;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[_clientServerControl( nMode := Tc2_TcpIp.CONNECT_MODE_ENABLEDBG);]]></ST>
    </Implementation>
    <Method Name="Connect" Id="{e1b034f2-070e-4d08-81cf-cdc063f262be}">
      <Declaration><![CDATA[METHOD Connect : BOOL
VAR_INPUT
	Ipv4Address	: Tc2_System.T_IPv4Addr;
	Port		: UINT;
END_VAR

VAR_INST
	state	: E_SocketConnectState;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.IsConnected = FALSE THEN
	_clientServerControl.bEnable := TRUE;
	_clientServerControl.sRemoteHost := Ipv4Address;
	_clientServerControl.nRemotePort := Port;
	_clientServerControl.sSrvNetID := '';
ELSE
	Connect := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Disconnect" Id="{d19beda7-1d0e-4fc3-a093-6322a6422700}">
      <Declaration><![CDATA[METHOD Disconnect : BOOL
VAR_INPUT
END_VAR

VAR_INST
	state	: E_SocketDisconnectState;
END_VAR

VAR
	emptySocketHandle	: Tc2_TcpIp.T_HSOCKET;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[_clientServerControl.bEnable := FALSE;
Disconnect := NOT THIS^.IsConnected;


]]></ST>
      </Implementation>
    </Method>
    <Property Name="Error" Id="{60d8bc34-46e0-454f-8a36-60e55751a023}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'variable'}
PROPERTY Error : BOOL]]></Declaration>
      <Get Name="Get" Id="{532dae0a-8ce1-4636-9534-c59315d8a95b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Error := _clientServerControl.bError OR (_clientServerControl.eState = Tc2_TcpIp.E_SocketConnectionState.eSOCKET_SUSPENDED and not _clientServerControl.bBusy);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsConnected" Id="{62428a97-7ac1-4a7f-b09f-13dad2b343d4}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'variable'}
PROPERTY PUBLIC IsConnected : BOOL]]></Declaration>
      <Get Name="Get" Id="{eb13dccb-aa08-41f0-8bbc-7f030a9f8461}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsConnected := _clientServerControl.eState = Tc2_TcpIp.E_SocketConnectionState.eSOCKET_CONNECTED;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="SendAscii" Id="{ce4f5b3c-a3f8-4f3f-9b3a-39768c4c33f7}">
      <Declaration><![CDATA[// Sends ASCII data via TCP/IP and returns TRUE when done. Response can be foind in the refResponse.
METHOD SendAscii : BOOL
VAR_INPUT
	sCommand			: Tc2_System.T_MaxString;	// Command to be send
	sCommandAcknowledgeResponse		: STRING;	// Response string that should be found when sending a command, before a new command can be sent
	refResponse			: REFERENCE TO Tc2_System.T_MaxString;	// Response variable - data is written to this variable
END_VAR

VAR_INST
	state				: E_SocketSendState;
	arrSendDataBytes	: ARRAY[0..255] OF BYTE;
	nSendDataCount		: UDINT;
	response	: Tc2_System.T_MaxString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE state OF
	E_SocketSendState.READY:
		_socketSend(bExecute := FALSE);
		IF sCommand <> '' THEN
			// Clear array for new data
			Tc2_System.MEMSET(
				destAddr := ADR(arrSendDataBytes),
				n := SIZEOF(arrSendDataBytes),
				fillByte := 0);
				
			// Prepare data
			Tc2_System.MEMCPY(
				destAddr := ADR(arrSendDataBytes),
				n := SIZEOF(sCommand),
				srcAddr := ADR(sCommand));

			response := '';
			// Get the data count, no empty bytes
			nSendDataCount := 0;
			FOR nSendDataCount := 0 TO SIZEOF(arrSendDataBytes) BY 1 DO
				IF arrSendDataBytes[nSendDataCount] = 0 THEN
					EXIT;
				END_IF
			END_FOR

			// Send data
			_socketSend(
				bExecute := TRUE,
				cbLen := nSendDataCount,
				pSrc := ADR(arrSendDataBytes),
				hSocket := _clientServerControl.hSocket);
				
			state := E_SocketSendState.SENDING;
		END_IF
	
	E_SocketSendState.SENDING:
		_socketSend(bExecute := FALSE);
		IF _socketSend.bError THEN 
			state := E_SocketSendState.ERROR;
		ELSIF _socketSend.bBusy = FALSE THEN
			state := E_SocketSendState.AWAIT_RESPONSE;
			_socketReceive(bExecute := FALSE);
			_socketReceive(
				bExecute := TRUE,
				hSocket := _clientServerControl.hSocket,
				cbLen := SIZEOF(response),
				pDest := ADR(response),
				tTimeout := T#5S);
		END_IF
		
	E_SocketSendState.AWAIT_RESPONSE:
		_socketReceive(bExecute := FALSE);
		IF _socketReceive.bError THEN
			state := E_SocketSendState.ERROR;
		ELSIF _socketReceive.bBusy = FALSE AND Tc2_Standard.FIND(STR1 := response, STR2 := sCommandAcknowledgeResponse) <> 0 THEN
			state := E_SocketSendState.READY;
			refResponse := response;
			SendAscii := TRUE;
		END_IF
	
	E_SocketSendState.ERROR:
		THIS^.Disconnect();
		state := E_SocketSendState.READY;
END_CASE]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>